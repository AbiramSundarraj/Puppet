# Puppet DSL: Resource Declarations, Manifests, Classes, and Modules

## Puppet DSL Overview

Puppet uses its own **Domain-Specific Language (DSL)** to define system configuration. The DSL is declarative, meaning you describe the **desired state**, and Puppet enforces it automatically.

The DSL is centered around:

* **Resources**
* **Resource declarations**
* **Manifests**
* **Classes**
* **Modules**
* **Special keywords** like `include`

This page explains how these concepts work together inside a standard Puppet environment.

---

# Resource Declarations

A **resource declaration** describes a single configuration item such as a package, user, file, or service.

Basic syntax:

```puppet
type { 'title':
  attribute => value,
  attribute => value,
}
```

Example:

```puppet
package { 'httpd':
  ensure => installed,
}
```

Key points:

* Resources are **idempotent** (safe to run repeatedly)
* Declared using the DSL
* Become part of your node’s **catalog**

Resource declarations are placed inside **manifests** or **classes**.

---

# Manifests

A **manifest** is a `.pp` file containing Puppet DSL code.

Common locations:

* `manifests/site.pp` (site-level configuration)
* Inside modules: `modules/<modulename>/manifests/*.pp`

A manifest can contain:

* Resource declarations
* Classes
* Variables
* Conditionals
* Node definitions

Example manifest:

```puppet
# manifests/site.pp
node 'web01' {
  package { 'httpd': ensure => installed }
  service { 'httpd': ensure => running }
}
```

Manifests are the building blocks for larger structures like **classes** and **modules**.

---

# Classes

A **class** groups resources into a reusable unit.

Classes help you:

* Organize code
* Reuse the same configuration on multiple nodes
* Follow Puppet module standard structure

Example class:

```puppet
class app_nginx {
  package { 'nginx':
    ensure => installed,
  }

  service { 'nginx':
    ensure => running,
    enable => true,
  }
}
```

Classes are defined inside module manifests and applied using the `include` keyword.

---

## Using the `include` Keyword

`include` tells Puppet to compile a class and add its resources to the catalog.

Example:

```puppet
include app_nginx
```

Important notes:

* `include` **does not** pass parameters
* If the class is already included, Puppet will skip it (idempotent behavior)
* It is the most common class usage method in `site.pp` or other manifests

---

# Predefined Locations (Where Puppet Looks for Things)

Puppet follows a **standard directory layout** when searching for classes, modules, and manifests.

Typical structure:

```
/etc/puppetlabs/code/environments/production/
│
├─ manifests/
│    └─ site.pp
│
├─ modules/
│    ├─ app_nginx/
│    │     ├─ manifests/
│    │     │     └─ init.pp
│    │     └─ files/
│    ├─ app_nmap/
```

Search behavior:

* When you write `include app_nginx`
* Puppet looks for: `modules/app_nginx/manifests/init.pp`

This brings us to the most important file in every Puppet module: **init.pp**

---

# Puppet Module

A **module** is the highest-level building block of Puppet code.

A module contains:

* Classes
* Files
* Templates
* Manifests
* Custom types/providers (optional)

Example module layout:

```
app_nginx/
├── manifests/
│     └── init.pp
├── files/
├── templates/
```

A module must contain a **primary class**, usually defined in `init.pp`.

Modules allow Puppet code to be reusable, shareable, and version-controlled.

---

# init.pp (The Entry Point of a Module)

`init.pp` defines the **main class** of a module.

If your module is named `app_nginx`, then:

* The module’s main class is **`app_nginx`**
* It must be defined in:

```
modules/app_nginx/manifests/init.pp
```

Example `init.pp`:

```puppet
class app_nginx {
  package { 'nginx':
    ensure => installed,
  }

  service { 'nginx':
    ensure => running,
  }
}
```

When you run:

```puppet
include app_nginx
```

Puppet automatically loads this `init.pp` file.

`init.pp` is the **entry point**, making the module functional and discoverable.

---

# How Everything Connects Together

1. **You declare a class** using Puppet DSL
   → Class is stored inside module `/manifests/init.pp`

2. **You include the class**
   → Puppet locates the module

3. **Module’s init.pp is loaded**
   → Resources inside the class are compiled

4. **Resources become part of the catalog**
   → Puppet applies them to the node

5. **Files/Templates** inside the module support these resources if needed

This chain is the core workflow of Puppet DSL.