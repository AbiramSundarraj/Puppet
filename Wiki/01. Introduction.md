# Puppet Basics

## Puppet Introduction

Puppet is a configuration management and automation tool used to define, enforce and maintain the desired state of infrastructure. It follows a declarative approach where you describe **what** you want, and Puppet figures out **how** to achieve it.
It is commonly used to automate tasks such as installing packages, managing files, configuring services, enforcing security settings, orchestrating deployments, and maintaining consistency across many servers.

Key components of Puppet:

* **Puppet Master (Server)** – compiles catalogs.
* **Puppet Agent (Node)** – applies configurations.
* **Manifests** – files containing Puppet code (`.pp`).
* **Catalog** – a compiled list of resources and their desired states.
* **Facter** – gathers system facts (OS, memory, hostname, etc.).
* **Modules** – reusable collections of classes, manifests, files, templates, etc.

---

## Resources (Idempotency & Declarative State)

### What is a Resource?

A **resource** is the fundamental unit of configuration in Puppet.
Each resource describes a single item on the system—like a file, user, package, or service.

Example:

```puppet
package { 'httpd':
  ensure => installed,
}
```

### Idempotent

Puppet resources are **idempotent**, meaning:

* No matter how many times you apply Puppet,
* The final state **remains the same**,
* And Puppet makes changes **only if needed**.

Example:

* If the package is already installed, Puppet does nothing.
* If it’s not installed, Puppet installs it.

This ensures safe, repeatable automation.

### Declarative State

Puppet is declarative, meaning you specify **the desired final state**, not the steps to get there.

Example:

```puppet
file { '/etc/motd':
  ensure  => file,
  content => "Welcome\n",
}
```

You’re not telling Puppet *how* to create a file…
You’re just declaring that the file **must exist with this content**, and Puppet enforces it.

---

## RAL (Resource Abstraction Layer)

The **Resource Abstraction Layer (RAL)** is the part of Puppet that:

* Takes your Puppet code (resources)
* Abstracts away OS-level differences
* Ensures consistent behavior across different platforms (Linux, Windows, etc.)

How it works:

1. You write a resource (`package { 'nmap': ensure => installed }`)
2. RAL translates it into OS-specific actions
3. Puppet applies those actions using an appropriate **provider**

For example:

* On **RHEL/CentOS/Rocky**: package installation uses `yum` or `dnf`
* On **Debian/Ubuntu**: package installation uses `apt`
* On **Windows**: Puppet may use MSI or Chocolatey

With RAL, the same Puppet code works everywhere.

---

## Providers

A **provider** is the Puppet component that implements how a resource is managed on a specific OS or tool.

Example:
Resource: `package`
Possible providers:

* `yum`
* `dnf`
* `apt`
* `gem`
* `pip`
* `rpm`
* `chocolatey`

Puppet automatically selects the correct provider based on:

* OS type
* Available tools

You can also specify a provider manually:

```puppet
package { 'rack':
  ensure   => installed,
  provider => 'gem',
}
```

Another example with the `service` resource:

* `systemd`
* `init`
* `upstart`
* `windows`

Providers help Puppet offer the same interface (resource types) across different operating systems.